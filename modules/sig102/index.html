<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Kalman Filter and Linear Algebra">
  <title>SIG 102 - FRC Team 3512</title>
  <link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>
  <table class="title">
    <tr><td>
      <h1 class="center">
        Signal Processing 102<br> <small>Kalman Filter and Linear Algebra</small>
      </h1>
    </td></tr>
  </table>

  <p>
    <strong>Prerequisites:</strong> <a href="../sig101/">SIG 101</a>
  </p>

  <hr>

  <h2 id="Introduction">Introduction</h2>
  <p class="module">
    When I can, I point to other online resources that sufficiently explain or illustrate material because I don't like duplicating work. <a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">This</a> guide to Kalman filters is very well written in my opinion and includes graphics which I couldn't hope to replicate (I don't do graphics design well). Apparently he used Photoshop and a stylus.
  </p>

  <h2 id="Implementation">Implementation</h2>
  <p class="module">
    Now that the theoretical groundwork has been laid, I'm going to present a Kalman filter implementation written in C++ that our team used in 2013. That year, we our robot had a flywheel and we needed to measure its speed. We used a Hall's Effect sensor to produce analog voltage pulses from gear teeth rotating by it. A Schmitt trigger was used to turn these analog voltages into well defined digital values we could count in software. The speeds calculated where really noisy, so we employed a filter to allow the use of larger K<sub>d</sub> terms in the flywheel's PID controller to decrease settling time (see <a href="../ct101/index.html">CT 101</a> for more on PID controllers). This implementation only used one input, so it functioned like a sophisticated averaging technique. It did, however, work much better than a rolling average filter; it filtered the noise out sufficiently while introducing less lag.
  </p>

  </p>
  <pre>
// =============================================================================
// File Name: KalmanFilter.hpp
// Description: Implements a Kalman filter for single input filtering
// Author: FRC Team 3512, Spartatroniks
// =============================================================================

#ifndef KALMAN_FILTER_HPP
#define KALMAN_FILTER_HPP

#include &lt;mutex&gt;
#include &lt;chrono&gt;

class KalmanFilter {
public:
    KalmanFilter(double Q, double R);

    void update(double input);

    void setQ(double Q);
    void setR(double R);

    // Return the filtered value
    double getEstimate();

    void reset();

private:
    // Used for getting and setting variables between main and sampling thread
    std::recursive_mutex m_dataMutex;

    // Running estimate of state calculated by filter
    double m_xHat;

    // Covariance of error
    double m_P;

    // Process noise variance
    double m_Q;

    // Measurement noise variance
    double m_R;

    // Holds dt in update()
    std::chrono::duration<double> m_dt;

    // Used to find dt in update()
    std::chrono::time_point<std::chrono::system_clock> m_lastTime;

    // If true, update() sets current estimate to first measurement
    bool m_firstRun;
};

#endif // KALMAN_FILTER_HPP
  </pre>
  <pre>

// =============================================================================
// File Name: KalmanFilter.cpp
// Description: Implements a Kalman filter for single input filtering
// Author: FRC Team 3512, Spartatroniks
// =============================================================================

#include "KalmanFilter.hpp"

KalmanFilter::KalmanFilter(double Q, double R) :
    m_Q(Q),
    m_R(R) {
    reset();
}

void KalmanFilter::update(double input) {
    std::lock_guard<std::recursive_mutex> lock(m_dataMutex);

    // Get the current dt since the last call to update()
    m_dt = std::chrono::system_clock::now() - m_lastTime;

    // Initialize estimate to measured value
    if (m_firstRun) {
        m_xHat = input;

        m_firstRun = false;
    }

    // Make a prediction - project the error covariance ahead
    m_P += m_Q * m_dt.count();

    /* Calculate the Kalman gain
     *   (m_P + m_R) is S, the estimate error
     */
    double K = m_P / (m_P + m_R);

    /* Update estimate with measurement zk (z_measured)
     *   'input' is zk in this equation
     *   (input - m_xHat) is y, the innovation
     */
    m_xHat += K * (input - m_xHat);

    // Correct error covariance
    m_P -= K * m_P;

    // Test for NaN (all comparisons with NaN will be false)
    if ((!(m_xHat > 0.0)) && (!(m_xHat < 0.0))) {
        m_xHat = 0.0;
    }

    // Update the previous time for the next delta
    m_lastTime = std::chrono::system_clock::now();
}

void KalmanFilter::setQ(double Q) {
    std::lock_guard<std::recursive_mutex> lock(m_dataMutex);
    m_Q = Q;
}

void KalmanFilter::setR(double R) {
    std::lock_guard<std::recursive_mutex> lock(m_dataMutex);
    m_R = R;
}

double KalmanFilter::getEstimate() {
    std::lock_guard<std::recursive_mutex> lock(m_dataMutex);
    return m_xHat;
}

void KalmanFilter::reset() {
    std::lock_guard<std::recursive_mutex> lock(m_dataMutex);

    m_xHat = 0.0;
    m_P = 0.0;
    m_lastTime = std::chrono::system_clock::now();
    m_firstRun = true;
}
  </pre>

  <h2 id="Filter_Tuning">Filter Tuning</h2>
  <p class="module">
    Normally, one would gather sample measurements to determine the optimum values for the process noise <i>Q</i> and measurement noise <i>R</i>. I didn't know how to do that in 2013, so I found values that worked through trial and error. That only took about an hour, but I don't see that process working for more complicated systems which use multidimensional Kalman filters.
  </p>
</body>
</html>

