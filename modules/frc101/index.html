<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="description" content="Robot Software"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FRC 101 - FRC Team 3512</title>
  <script src="../../toc.js"></script>
  <link rel="stylesheet" type="text/css" href="../../style.css"/>
</head>
<body onload="tableOfContents();">
  <div class="title">
    <h1>FRC 101<br/> <small>Robot Software</small></h1>
    <div class="prereq">
      <strong>Prerequisites:</strong> <a href="../rt101/">RT 101</a><br/>
      <strong>Corequisites:</strong> <a href="../cs101/">CS 101</a>, <a href="../ct101/">CT 101</a>
    </div>
  </div>

  <div id="toc"></div>

  <h2 id="Disclaimer">Disclaimer</h2>
  <p>
    While the goal every year is to create the most competitive robot possible with the tools and abstractions we've built up so far, we want everyone to understand the <i>entire</i> robot's code base each year. Therefore, reusing complicated code from previous year's robots is off-limits unless everyone understands how it works internally (if it breaks, they'll know how to attempt fixing it). Writing documentation or tutorials/labs is encouraged to help other students understand pieces of software quicker in the future.
  </p>

  <h2 id="Installation">Installation</h2>
  <p>
    Eclipse should already be installed from following the <a href="../../bootstrap/">bootstrap page</a>. For robot software development, follow the instructions <a href="https://wpilib.screenstepslive.com/s/4485/m/13503/l/145002-installing-eclipse-c-java">here</a> to install the FRC plugins and roboRIO ARM toolchain. Other robot software resources can be found <a href="http://wpilib.screenstepslive.com/s/4485/m/13503/c/86641">here</a>.
  </p>

  <h2 id="Design_Patterns">Design Patterns</h2>
  <p>
    Design patterns are used all over software development. Expert programmers know the idiomatic design patterns for their language to solve a problem quickly, efficiently, and with few bugs. We have common design patterns in robot software. A list of design patterns with descriptions, usage advice, and examples is provided below.
  </p>
  <p>
    See <a href="https://wpilib.screenstepslive.com/s/4485/m/13810">this WPILib ScreenSteps page</a> for more resources on performing various common robot tasks in C++. We have <a href="https://github.com/Team3512/">robot software</a> from previous years on GitHub that students can study, understand, and potentially reuse.
  </p>

  <h3 id="SampleRobot_control_flow">SampleRobot control flow</h3>
  <p>
    The <code>SampleRobot</code> robot base class provides several virtual functions the subclass can override (see <a href="https://github.com/wpilibsuite/allwpilib/blob/master/wpilibc/athena/include/SampleRobot.h">SampleRobot.h</a>).
  </p>
  <p>
    The functions <code>Disabled()</code>, <code>Autonomous()</code>, and <code>OperatorControl()</code> correspond to the modes in which the Driver Station can set the robot. They are called once upon switching to each mode. After one of the functions exits, <code>RobotBase</code> will continuously wait for Driver Station data until another mode change occurs. Therefore, code in each function should be run in a while loop until the mode changes. The following is an example Robot.cpp.
  </p>
  <pre>#include "Robot.hpp"

using namespace std::chrono_literals;

void Robot::Autonomous() {
  while (IsAutonomous() &amp;&amp; IsEnabled()) {
    // Perform autonomous tasks

    std::this_thread::sleep_for(10ms);
  }
}

void Robot::Disabled() {
  while (IsDisabled()) {
    // Wait for robot to become enabled

    std::this_thread::sleep_for(10ms);
  }
}

void Robot::OperatorControl() {
  while (IsOperatorControl() &amp;&amp; IsEnabled()) {
    // Perform normal robot actions and check for user input

    std::this_thread::sleep_for(10ms);
  }
}</pre>

  <h3 id="Drivetrain_with_joysticks">Drivetrain with joysticks</h3>
  <p>
    There are multiple ways to drive a robot around; some are in open loop (the driver provides direct input to the system) and others are in closed loop (autonomous driving using encoders). This section discusses the former while the latter is covered in detail in <a href="../ct102/">CT 102</a>.
  </p>
  <p>
    The two most common ways to drive a robot manually are with WPILib's RobotDrive class and with another drive class implementing a custom drive scheme (e.g., Cheesy Drive). To make a four-wheeled robot drive around as quick as possible, the following is all that is required.
  </p>
  <pre>CANTalon flMotor(0);
CANTalon frMotor(1);
CANTalon rlMotor(2);
CANTalon rrMotor(3);
RobotDrive drive(flMotor, frMotor, rlMotor, rrMotor);
Joystick forwardJoystick(0);
Joystick turnJoystick(1);

while (IsOperatorControl() &amp;&amp; IsEnabled()) {
  drive.ArcadeDrive(forwardJoystick.GetX(), turnJoystick.GetY());
}</pre>
  <p>
    While it is easy to use, a creating custom drive scheme allows for more complex functionality and features. Alternatively, WPILib may simply not support your drive train configuration. To implement a custom drive scheme, the following is required.
  </p>
  <ul>
    <li>A function taking joystick axis inputs</li>
    <li>A method of converting those inputs from normalized values in the range [-1..1] into motor commands in the range [-1..1] (known as <a href="https://en.wikipedia.org/wiki/Inverse_kinematics">inverse kinematics</a>)</li>
  </ul>
  <p>
    The following is an example of one.
  </p>
  <pre>#include &lt;cmath&gt;

void DriveTrain::Drive(double moveValue, double rotateValue) {
  if (moveValue &gt; 1.0) {
    moveValue = 1.0;
  } else if (moveValue &lt; -1.0) {
    moveValue = -1.0;
  }
  if (rotateValue &gt; 1.0) {
    rotateValue = 1.0;
  } else if (rotateValue &lt; -1.0) {
    rotateValue = -1.0;
  }

  // Local variables to hold the computed PWM values for the motors
  double leftMotorOutput;
  double rightMotorOutput;

  if (moveValue &gt; 0.0) {
    if (rotateValue &gt; 0.0) {
      leftMotorOutput = moveValue - rotateValue;
      rightMotorOutput = std::max(moveValue, rotateValue);
    } else {
      leftMotorOutput = std::max(moveValue, -rotateValue);
      rightMotorOutput = moveValue + rotateValue;
    }
  } else {
    if (rotateValue &gt; 0.0) {
      leftMotorOutput = -std::max(-moveValue, rotateValue);
      rightMotorOutput = moveValue + rotateValue;
    } else {
      leftMotorOutput = moveValue - rotateValue;
      rightMotorOutput = -std::max(-moveValue, -rotateValue);
    }
  }

  SetLeftRightMotorOutputs(leftMotorOutput, rightMotorOutput);
}</pre>
  <p>
    Cheesy Drive is a popular method of driving robots that maintains a constant turning radius at different linear speeds. See <a href="https://github.com/Team3512/Robot-2017/blob/master/src/Subsystems/DriveTrain.cpp#L38">here</a> for an implementation. The following explains each part of it.
  </p>
  <br/>
  <p>
    This function takes a throttle value, a turn value, and a boolean representing whether the center of rotation should be within the robot's chassis.
  <pre>void DriveTrain::Drive(double throttle, double turn, bool isQuickTurn) {</pre>
  <br/>
  <p>
    This simply inverts the throttle since pushing forward on the joystick produces a negative value.
  </p>
  <pre>    throttle *= -1;</pre>
  <br/>
  <pre>
    // Limit values to [-1 .. 1]
    throttle = Limit(throttle, 1.0);
    turn = Limit(turn, 1.0);</pre>
  <br/>
  <p>
    This applies a deadband around the center of the range to compensate for joysticks which give non-zero values for the origin.
  </p>
  <pre>
    /* Apply joystick deadband
     * (Negate turn since joystick X-axis is reversed)
     */
    throttle = ApplyDeadband(throttle, m_deadband);
    turn = ApplyDeadband(turn, m_deadband);</pre>
  <br/>
  <pre>
    double turnNonLinearity = k_turnNonLinearity;

    /* Apply a sine function that's scaled to make turning sensitivity feel
     * better. turnNonLinearity should never be zero, but can be close.
     */
    turn = std::sin(M_PI / 2.0 * turnNonLinearity * turn) /
           std::sin(M_PI / 2.0 * turnNonLinearity);</pre>
  <br/>
  <pre>
    double angularPower = 0.0;
    double linearPower = throttle;
    double leftPwm = linearPower, rightPwm = linearPower;</pre>
  <br/>
  <p>
    Negative inertia applies a rotation in the direction opposite of rotation when the driver requests a large change in the turning rate. This overcomes the moment of inertia of the robot and makes the robot more responsive. Names prefixed with "k_" are constants.
  </p>
  <pre>
    double negInertia = turn - m_oldTurn;
    m_oldTurn = turn;

    // Negative inertia!
    double negInertiaScalar;
    if (turn * negInertia &gt; 0) {
        negInertiaScalar = k_inertiaDampen;
    } else {
        if (std::fabs(turn) &gt; 0.65) {
            negInertiaScalar = k_inertiaHighTurn;
        } else {
            negInertiaScalar = k_inertiaLowTurn;
        }
    }

    m_negInertiaAccumulator +=
        negInertia * negInertiaScalar;  // adds negInertiaPower

    // Apply negative inertia
    turn += m_negInertiaAccumulator;
    if (m_negInertiaAccumulator &gt; 1) {
        m_negInertiaAccumulator -= 1;
    } else if (m_negInertiaAccumulator &lt; -1) {
        m_negInertiaAccumulator += 1;
    } else {
        m_negInertiaAccumulator = 0;
    }</pre>
  <br/>
  <p>
    QuickTurn allows a turning radius within the robot. The quick stop accumulator performs a similar function to negative inertia by opposing the robot's rotation when the driver requests the turn to stop (the joystick turn value is close to zero). This makes the robot's turns stiffer.
  </p>
  <pre>
    // QuickTurn!
    if (isQuickTurn) {
        if (std::fabs(linearPower) &lt; 0.2) {
            double alpha = 0.1;
            m_quickStopAccumulator = (1 - alpha) * m_quickStopAccumulator +
                                     alpha * Limit(turn, 1.0) * 5;
        }

        angularPower = turn;
    } else {
        angularPower =
            std::fabs(throttle) * turn * m_sensitivity - m_quickStopAccumulator;
        if (m_quickStopAccumulator &gt; 1) {
            m_quickStopAccumulator -= 1;
        } else if (m_quickStopAccumulator &lt; -1) {
            m_quickStopAccumulator += 1;
        } else {
            m_quickStopAccumulator = 0.0;
        }
    }</pre>
  <br/>
  <p>
    This performs calculations to ensure the robot performs the same radius turn at all forward speeds.
  </p>
  <pre>
    // Adjust straight path for turn
    leftPwm += angularPower;
    rightPwm -= angularPower;

    // Limit PWM bounds to [-1..1]
    if (leftPwm &gt; 1.0) {
        // If overpowered turning enabled
        if (isQuickTurn) {
            rightPwm -= (leftPwm - 1.0);
        }

        leftPwm = 1.0;
    } else if (rightPwm &gt; 1.0) {
        // If overpowered turning enabled
        if (isQuickTurn) {
            leftPwm -= (rightPwm - 1.0);
        }

        rightPwm = 1.0;
    } else if (leftPwm &lt; -1.0) {
        // If overpowered turning enabled
        if (isQuickTurn) {
            rightPwm += (-leftPwm - 1.0);
        }

        leftPwm = -1.0;
    } else if (rightPwm &lt; -1.0) {
        // If overpowered turning enabled
        if (isQuickTurn) {
            leftPwm += (-rightPwm - 1.0);
        }

        rightPwm = -1.0;
    }</pre>
  <br/>
  <p>
    This sets the motor speeds to those that were calculated.
  </p>
  <pre>
    m_leftGrbx.Set(leftPwm);
    m_rightGrbx.Set(rightPwm);
}</pre>

  <h3 id="ButtonTracker_internals">ButtonTracker internals</h3>
  <p>
    In <code>OperatorControl()</code>, performing actions when the user presses a button is typically required. The simplest way to do this uses a Joystick and two booleans for tracking the past and current state of one of its buttons.
  </p>
  <pre>Joystick joystick(0);
bool oldButtonState = false;
bool newButtonState = false;

while (IsOperatorControl() &amp;&amp; IsEnabled()) {
  // If button was pressed
  if (!oldButtonState &amp;&amp; newButtonState) {
    std::cout &lt;&lt; "Joystick button 2 pressed" &lt;&lt; std::endl;
  }

  // If button was released
  if (oldButtonState &amp;&amp; !newButtonState) {
    std::cout &lt;&lt; "Joystick button 2 released" &lt;&lt; std::endl;
  }

  // If button was held
  if (oldButtonState &amp;&amp; newButtonState) {
    std::cout &lt;&lt; "Joystick button 2 held" &lt;&lt; std::endl;
  }

  // Update step
  oldButtonState = newButtonState;
  newButtonState = joystick.GetRawButton(2);
}
</pre>
  <p>
    First, the booleans are initialized to <code>false</code> to represent a released button. At the end of every while loop iteration, the current state is copied to the old state and a new one is obtained from the joystick. By performing this operation once every loop iteration, we are guaranteed to see every rising or trailing edge and can act on it.
  </p>
  <p>
    Unfortunately, as more buttons are checked, this approach becomes messy and unmaintainable. Also, the possibility of mistyping a boolean check increases and encourages copy-pasting code. We wrote the <a href="https://github.com/Team3512/Robot-2016/blob/master/src/ButtonTracker.hpp">ButtonTracker</a> class to provide an abstraction for detecting leading and trailing edges in button state which eliminates boilerplate. See an example of its usage below.
  </p>
  <pre>ButtonTracker joystick2Buttons(2);

while (IsOperatorControl() &amp;&amp; IsEnabled()) {
  if (joystick2Buttons.PressedButton(2)) {
    std::cout &lt;&lt; "Joystick button 2 pressed" &lt;&lt; std::endl;
  }

  if (joystick2Buttons.ReleasedButton(2)) {
    std::cout &lt;&lt; "Joystick button 2 released" &lt;&lt; std::endl;
  }

  if (joystick2Buttons.HeldButton(2)) {
    std::cout &lt;&lt; "Joystick button 2 held" &lt;&lt; std::endl;
  }

  // Update step
  joystick2Buttons.Update();
}</pre>
  <p>
    To check other buttons, one has to simply pass a different button number to the appropriate member function. To check other joysticks, one has to simply make another instance of ButtonTracker and add it to the update step at the bottom of the while loop.
  </p>

  <h3 id="Toggle_solenoid_state">Toggle solenoid state</h3>
  <p>
    Toggling solenoids to extend or retract mechanisms can be done with the following pattern.
  </p>
  <pre>Solenoid solenoid(1);

solenoid.Set(!solenoid.Get());</pre>

  <h3 id="Spin_motor_with_joystick">Spin motor with joystick</h3>
  <p>
    This pattern is typically used to manually move mechanisms driven by a motor up or down.
  </p>
  <pre>Joystick joystick(0);
CANTalon motor(1);

motor.Set(-joystick.GetY());</pre>

  <h3 id="State_machines">State machines</h3>
  <p>
    See the <a href="../ct101/state-machine/">state machine</a> and <a href="../ct101/event-framework">event framework</a> labs for how we implement state machines, since they are commonly used tools.
  </p>

  <h3 id="Actuate_motor_to_several_points_quickly">Actuate motor to several points quickly</h3>
  <p>
    This is done when a mechanism driven by a motor should be moved from one position to another reliably and quickly. Note that this should only be done when the device could potentially be set to more than two positions within its range. If only two are required, a solenoid should be used instead.
  </p>
  <p>
    See the labs in <a href="../ct101/">CT 101</a> for examples on how to do this.
  </p>
  <p>
    The following is the "Encoder" example provided in the 2017 WPILib Eclipse plugins.
  </p>
  <pre>
#include &lt;Encoder.h&gt;
#include &lt;SampleRobot.h&gt;
#include &lt;SmartDashboard/SmartDashboard.h&gt;
#include &lt;Timer.h&gt;

/**
 * Sample program displaying the value of a quadrature encoder on the
 *   SmartDashboard.
 * Quadrature Encoders are digital sensors which can detect the amount the
 *   encoder has rotated since starting as well as the direction in which the
 *   encoder shaft is rotating. However, encoders can not tell you the absolute
 *   position of the encoder shaft (ie, it considers where it starts to be the
 *   zero position, no matter where it starts), and so can only tell you how
 *   much the encoder has rotated since starting.
 * Depending on the precision of an encoder, it will have fewer or greater
 *   ticks per revolution; the number of ticks per revolution will affect the
 *   conversion between ticks and distance, as specified by DistancePerPulse.
 * One of the most common uses of encoders is in the drivetrain, so that the
 *   distance that the robot drives can be precisely controlled during the
 *   autonomous mode.
 */
class Robot: public frc::SampleRobot {
    /**
     * The Encoder object is constructed with 4 parameters, the last two being
     *   optional.
     * The first two parameters (1, 2 in this case) refer to the ports on the
     *   roboRIO which the encoder uses. Because a quadrature encoder has
     *   two signal wires, the signal from two DIO ports on the roboRIO are used.
     * The third (optional) parameter is a boolean which defaults to false.
     *   If you set this parameter to true, the direction of the encoder will
     *   be reversed, in case it makes more sense mechanically.
     * The final (optional) parameter specifies encoding rate (k1X, k2X, or k4X)
     *   and defaults to k4X. Faster (k4X) encoding gives greater positional
     *   precision but more noise in the rate.
     */
    frc::Encoder m_encoder { 1, 2, false, Encoder::k4X };

    /**
     * Time to wait between updating SmartDashboard values.
     * It is generally a good idea to stick a short wait in these loops
     *   to avoid hogging CPU power, especially as there will be no
     *   perceivable difference in the SmartDashboard display.
     */
    static constexpr double kUpdatePeriod = 0.005; // 5milliseconds / 0.005 seconds.

public:
    Robot() {
        /* Defines the number of samples to average when determining the rate.
         * On a quadrature encoder, values range from 1-255; larger values
         *   result in smoother but potentially less accurate rates than lower
         *   values.
         */
        m_encoder.SetSamplesToAverage(5);

        /* Defines how far the mechanism attached to the encoder moves per pulse.
         * In this case, we assume that a 360 count encoder is directly attached
         * to a 3 inch diameter (1.5inch radius) wheel, and that we want to
         * measure distance in inches.
         */
        m_encoder.SetDistancePerPulse(1.0 / 360.0 * 2.0 * 3.1415 * 1.5);

        /* Defines the lowest rate at which the encoder will not be considered
         *   stopped, for the purposes of the GetStopped() method.
         * Units are in distance / second, where distance refers to the units
         *   of distance that you are using, in this case inches.
         */
        m_encoder.SetMinRate(1.0);
    }

    /**
     * Retrieve various information from the encoder and display it on the
     *   SmartDashboard.
     */
    void OperatorControl() {
        while (IsOperatorControl() && IsEnabled()) {
            // Retrieve the net displacement of the Encoder since the lsat Reset.
            frc::SmartDashboard::PutNumber("Encoder Distance",
                    m_encoder.GetDistance());

            // Retrieve the current rate of the encoder.
            frc::SmartDashboard::PutNumber("Encoder Rate", m_encoder.GetRate());

            frc::Wait(kUpdatePeriod); // Wait a short bit before updating again.
        }
    }
};

START_ROBOT_CLASS(Robot)</pre>

  <h2 id="Project_Setup">Project Setup</h2>
  <p>
    Each year, a new robot project will need to be created in Gerrit (our code review platform) and on GitHub for our competition robot code. First, an admin should create a new empty repository in the Team3512 GitHub organization (no README or license) and in Gerrit. Give them a name and description following the form of the previous years' repositories like "Robot-2017" and "The source code for the 2017 FRC robot.". Next, clone the repository from Gerrit and add the following files to it. See below the list for exceptions in downloading the provided files.
  </p>

  <h3 id="Generic_Download">Generic Download</h3>
  <p>
    These files should be included in all of FRC Team 3512's software projects.
  </p>
  <ul>
    <li><a href="generic/.clang-format">.clang-format</a></li>
    <li><a href="generic/.gitignore">.gitignore</a></li>
    <li><a href="generic/.gitreview">.gitreview</a></li>
    <li><a href="generic/.styleguide">.styleguide</a></li>
    <li><a href="generic/.styleguide-license">.styleguide-license</a></li>
    <li><a href="generic/COPYING">COPYING</a></li>
    <li>README.md</li>
  </ul>
  <p>
    <code>.gitreview</code> will need the project name updated. <code>COPYING</code> will need the initial copyright year updated to the current year. <code>README.md</code> should be edited to be unique to the project.
  </p>

  <h3 id="Robot_Download">Robot Download</h3>
  <p>
    These files should only be included in robot code projects. Some replace the generic files listed above.
  </p>
  <ul>
    <li><a href="robot/.styleguide">.styleguide</a></li>
    <li><a href="robot/CMakeLists.txt">CMakeLists.txt</a></li>
    <li><a href="robot/README.md">README.md</a></li>
    <li><a href="robot/send-settings.sh">send-settings.sh</a></li>
    <li><a href="robot/src/Constants.hpp">src/Constants.hpp</a></li>
  </ul>
  <p>
    <code>README.md</code> will need the year and robot name updated. "?" can be used until the robot name is chosen. <code>src/Constants.hpp</code> is a file we typically use every year and is provided as a placeholder so the <code>src</code> folder is added to Git history.
  </p>

  <h3 id="Generated_via_Robot_Project">Generated via Robot Project</h3>
  <ul>
    <li><a href=".cproject">.cproject</a></li>
    <li><a href=".project">.project</a></li>
    <li><a href="build.properties">build.properties</a></li>
    <li><a href="build.xml">build.xml</a></li>
  </ul>
  <p>
    Change the following Eclipse project properties before copying the metadata files into the Git repository.
  </p>
  <ul>
    <li>Rename the "Debug" configuration to "Release" via the "Manage Configurations..." button</li>
    <li>"Cross GCC Compiler" and "Cross G++ Compiler" &gt; "Optimization" &gt; "Optimization Level" = "Optimize most" with "Other optimization flags" empty</li>
    <li>"Cross GCC Compiler" and "Cross G++ Compiler" &gt; "Debugging" &gt; "Debug Level" = "None"</li>
    <li>"Cross GCC Compiler" and "Cross G++ Compiler" &gt; "Miscellaneous" &gt; "Other flags" = "-c"</li>
    <li>"Cross G++ Linker" &gt; "General" &gt; "Omit all symbol information (-s)" = true</li>
  </ul>
  <p>
    The optimization level can be restored to "None" with "Other optimization flags" of "-Og" and debug level can be restored to "Maximum" when needed for debugging. However, the settings described here are used for performance and should probably be used in competition.
  </p>

  <h3 id="Initial_Commit">Initial Commit</h3>
  <p>
    After the files are added to the repository, they should be committed in the first commit with the commit message "Initial Commit". This can then be pushed to Gerrit for review or pushed directly to master by admins. Gerrit will automatically mirror commits to master on GitHub.
</body>
</html>
