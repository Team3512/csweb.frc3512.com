<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="description" content="Gerrit">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gerrit - FRC Team 3512</title>
  <script src="../../js/toc.js"></script>
  <link rel="stylesheet" type="text/css" href="../../css/style.css">
  <link rel="shortcut icon" type="image/ico" href="../../favicon.ico">
</head>
<body onload="tableOfContents();">
  <div id="content">
    <div class="title">
      <h1>Gerrit<br>
      <small>Git 2</small></h1>
    </div>
    <div class="prereq">
      <strong>Prerequisites:</strong> <a href="../git01/">Git 1</a>
    </div>
    <div id="toc"></div>
    <h2 id="Resources">Resources</h2>
    <ul>
      <li>
        <a href="https://github.com/Team3512/">GitHub</a> - mirrors of the code
        we've written for the robotics team reside here.
      </li>
      <li>
        <a href="https://gerrit.frc3512.com/">Gerrit</a> - we use Gerrit, which
        is based on Git, for code review.
      </li>
      <li>Git's <a href="https://git-scm.com/doc/">online documentation</a>.
      </li>
      <li>Git (advanced usage) lecture <a href="lecture/">slides</a>.
      </li>
      <li>
        <a href=
        "http://tom.preston-werner.com/2009/05/19/the-git-parable.html">The Git
        Parable</a> - an alternate explanation of Git terminology.
      </li>
      <li>
        <a href=
        "https://github.com/k88hudson/git-flight-rules/blob/master/README.md">Flight
        rules for Git</a>: solutions to common problems.
      </li>
      <li>
        <a href=
        "https://github.com/pluralsight/git-internals-pdf/releases/latest">PDF
        on Git internals</a> for those curious about how Git stores files and
        revisions.
      </li>
    </ul>
    <h2 id="Git_.28advanced_usage.29_lecture_notes">Git (advanced usage)
    lecture notes</h2>
    <h3 id="Versioning">Versioning</h3>
    <ul>
      <li>Easily get commit later? (tag)</li>
      <li>Getting to tagged commit later? (checkout)</li>
      <ul>
        <li>now in detached head state</li>
        <li>can 'git checkout master' to get back to tip of master</li>
        <li>can make commits</li>
        <ul>
          <li>make sure commits are saved?</li>
          <ul>
            <li>'git branch temp'</li>
            <li>'git checkout temp'</li>
          </ul>
          <li>Update master to temp... WARNING: destructive!</li>
          <ul>
            <li>'git branch -f master temp' (fine if changes on master were
            bad)</li>
            <li>'git checkout master'</li>
          </ul>
          <li>Or... merge it with HEAD</li>
          <ul>
            <li>Find commit from 'git reflog'</li>
            <li>checkout master</li>
            <li>'git merge HEAD@{1}' (where HEAD{1} is commit in temp branch
            from reflog)</li>
          </ul>
        </ul>
        <li>Remove temp branch since it's reachable by master at HEAD now</li>
        <ul>
          <li>'git branch -d temp'</li>
        </ul>
      </ul>
      <li>IF you just want to edit the commit checked out and not make a new
      one</li>
      <ul>
        <li>'git rebase -i' with edit mentioned next to commit</li>
        <ul>
          <li>triggers commmit --amend scenario -&gt; 'git rebase
          --continue'</li>
        </ul>
      </ul>
    </ul>
    <h3 id="Messing_with_history">Messing with history</h3>
    <ul>
      <li>Changing last commit</li>
      <ul>
        <li>Messed up commit message? (commit --amend)</li>
        <li>Forgot to add files or added wrong ones? (add/rm then commit
        --amend)</li>
      </ul>
      <li>Want to change a bunch of commits? rebase!</li>
      <ul>
        <li>'git rebase -i' is a fantastic tool</li>
        <li>Clean up a billion local commits that don't make sense apart?</li>
        <ul>
          <li>Compress commits w/ squash</li>
        </ul>
        <li>Reorder commits</li>
        <li>Remove commits</li>
      </ul>
      <li>WARNING: Only do this with commits that aren't public yet!</li>
    </ul>
    <h3 id="Nuclear_option_for_binary_files">Nuclear option for binary
    files</h3>
    <ul>
      <li>'git filter-branch --tree-filter 'rm -f largeFile.out' HEAD</li>
    </ul>
    <h2 id="Setup">Setup</h2>
    <p>Visit <code>gerrit.frc3512.com</code> and sign in / sign up.</p>
    <h3 id="Create_SSH_key_pair">Create SSH key pair</h3>
    <pre>ssh-keygen -t rsa -b 4096 -C "your_email@youremail.com"</pre>
    <h3 id="Add_public_key_to_Gerrit">Add public key to Gerrit</h3>
    <pre>cat ~/.ssh/id_rsa.pub</pre>
    <p>Copy the entire block, then navigate to the "SSH Public Key" settings of
    your user settings on Gerrit. Click "Add Key", paste the entire key, then
    click "Add".</p>
    <h3 id="Installing_git-review">Installing git-review</h3>
    <pre>pacman -S python
wget https://bootstrap.pypa.io/get-pip.py
python get-pip.py
pip install --user git-review</pre>
    <h3 id="Configuring_cloned_repository">Configuring cloned repository</h3>
    <pre>git clone ssh://user@gerrit.frc3512.com:29418/Robot-2017
cd Robot-2017
git review -s</pre>
    <h2 id="Usage">Usage</h2>
    <p>In Gerrit, features are submitted in branches with one commit per
    branch. Give each branch a name reflecting its content for easier
    management. Submit new patchsets and revisions of existing patchsets via
    the following command.</p>
    <pre>git review</pre>
    <h3 id="New_patchset">New patchset</h3>
    <p>Gerrit manages reviews on a per-commit basis. To start a review on a new
    patch, make sure the commit is on a separate branch from master. Check out
    that branch and run <code>git review</code>.</p>
    <p>Make sure new patchsets are created with <code>git commit</code>. Using
    <code>git commit --amend</code> will change a commit already merged
    upstream and lead to conflicts.</p>
    <h3 id="Revisions_to_patchset">Revisions to patchset</h3>
    <p>Any changes should be incorporated into the commit previously pushed by
    either amending or rebasing (not pushing a new commit on top of the old
    one). Gerrit tracks the revisions using the "Change-Id" line at the bottom
    of the commit message. <i>Make sure this line does not change and remains
    the last line</i> during commit message modifications. Otherwise, a new
    patchset will be created instead.</p>
    <p>Verify this was done correctly by inspecting the output of <code>git log
    master..HEAD</code>. There should be only one commit listed and its
    Change-Id should match the old one.</p>
    <h4 id="Uncommitted_changes">Uncommitted changes</h4>
    <pre>git commit --amend</pre>
    <h4 id="Squashing_committed_changes">Squashing committed changes</h4>
    <p>If a new commit or commits were made while working, they should be
    squashed into the first before submitting it all as a new revision. To do
    so, run</p>
    <pre>git rebase -i &lt;commit hash before your commits&gt;</pre>
    <p>The first commit in the resulting generated file should be set to "r"
    for "reword" if the commit message needs to be altered to include parts of
    the other two commits. The other commits should be set to "f" for "fixup"
    so their contents are squashed into the first commit. <code>git
    rebase</code> descriptions for other options are in the file comment.</p>
    <p>To clarify, making a new commit on top of it then running <code>git
    review</code> will make a new patchset. This is bad practice as the new
    commit is not a stand-alone feature.</p>
  </div>
</body>
</html>
